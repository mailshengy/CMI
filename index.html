<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Scratch Card by Scratch</title>
<link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
<style>
  :root{
    --card-w: 400px;
    --card-h: 600px;
    --front-img-size: 376px;
    --front-top: 12px;

    --paper: #ffffff;
    --offwhite-bg: #F8F8F6;

    --edge: rgba(0,0,0,.08);
    --shadow-lg: 0 16px 40px rgba(0,0,0,.18), 0 6px 14px rgba(0,0,0,.12);
    --thickness-z: -3px;

    /* Holographic controls (Initial values) */
    --holo-phase: 0deg;
    --holo-tilt-x: 0deg;
    --holo-intensity: 0.12;
    --holo-x: 50%;
    --holo-y: 45%;
  }

  body{
    margin:0; min-height:100vh;
    display:grid; place-items:center;
    background: var(--offwhite-bg);
    font-family: ui-sans-serif, system-ui, -apple-system;
  }

  .wrap{display:grid; justify-items:center; gap:12px; padding:16px;}

  .scene{
    width:min(96vw,520px);
    aspect-ratio:3/4;
    display:grid;place-items:center;
    perspective:1200px;
    user-select:none; touch-action:none;
  }

  .card{
    width:var(--card-w); height:var(--card-h); position:relative;
    transform-style:preserve-3d;
    transition:transform .6s cubic-bezier(.2,.8,.2,1);
    will-change:transform;
  }
  .card::after{
    content:""; position:absolute; inset:0; border-radius:16px;
    box-shadow:var(--shadow-lg);
    transform:translateZ(var(--thickness-z));
    pointer-events:none;
  }

  .face{
    position:absolute; inset:0; border-radius:16px; background:var(--paper);
    backface-visibility:hidden; -webkit-backface-visibility:hidden;
    transform-style:preserve-3d;
    /* Improved subtle paper texture (finer) */
    background-image:
      radial-gradient(circle at 26% 22%, rgba(0,0,0,.02), transparent 40%),
      radial-gradient(circle at 74% 12%, rgba(0,0,0,.018), transparent 40%),
      repeating-linear-gradient(135deg, rgba(0,0,0,.01) 0 1px, transparent 1px 6px),
      repeating-linear-gradient(45deg, rgba(0,0,0,.008) 0 1px, transparent 1px 6px);
    background-blend-mode:multiply;
  }
  .back{ transform:rotateY(180deg); }

  .front-art{
    position:absolute; top:var(--front-top); left:0; right:0; margin:auto;
    width:var(--front-img-size); height:var(--front-img-size);
    border-radius:12px; overflow:hidden; position:relative;
    box-shadow:0 8px 18px rgba(0,0,0,.16), inset 0 0 0 1px rgba(255,255,255,.5);
    background-color:#fff;
    /* Placeholder rainbow reveal image */
    background-image:conic-gradient(from 0deg,#ff3d3d,#ff7a00,#ffd100,#5bd400,#00c2ff,#7b5cff,#ff4bd8,#ff3d3d);
    background-size:cover;
  }

  .front-art::after{
    content:""; position:absolute; inset:-50%; /* More room to rotate */
    pointer-events:none;
    background:
      /* 1. White flare (driven by intensity) */
      radial-gradient(circle at var(--holo-x) var(--holo-y),
        rgba(255,255,255, calc(0.8 * var(--holo-intensity))) 0%,
        rgba(255,255,255, 0) 30%),
      
      /* 2. Spectral color shift (driven by intensity & phase) */
      conic-gradient(from var(--holo-phase) at var(--holo-x) var(--holo-y),
        hsla(0,   100%, 50%, calc(.25 * var(--holo-intensity))),
        hsla(60,  100%, 50%, calc(.25 * var(--holo-intensity))),
        hsla(120, 100%, 50%, calc(.25 * var(--holo-intensity))),
        hsla(180, 100%, 50%, calc(.25 * var(--holo-intensity))),
        hsla(240, 100%, 50%, calc(.25 * var(--holo-intensity))),
        hsla(300, 100%, 50%, calc(.25 * var(--holo-intensity))),
        hsla(360, 100%, 50%, calc(.25 * var(--holo-intensity)))
      );
    mix-blend-mode:color-dodge;
    transform:rotateX(var(--holo-tilt-x)) translateZ(0);
    z-index:2;
  }

  /* Scratch foil canvas above the image */
  .scratch-layer{
    position:absolute; inset:0;
    width:100%; height:100%;
    touch-action:none; cursor:crosshair;
    border-radius:12px;
    backface-visibility:hidden; -webkit-backface-visibility:hidden;
    z-index:3;
    display:block;
  }

  .signature{
    position:absolute;
    top:calc(var(--front-top) + var(--front-img-size) + 30px);
    left:0; right:0; text-align:center;
    font-family:'Permanent Marker', cursive;
    font-size:30px; color:#333; letter-spacing:0.5px;
    transform:translateZ(1px);
    user-select:none;
  }

  /* ======================================
    UPDATED REVEAL STAMP STYLES
    ======================================
  */
  .reveal-stamp{
    position:absolute;
    /* Moved from top to bottom */
    bottom: 30px; 
    left:0; right:0; text-align:center;
    /* Updated font: 500 weight, 12px size, new grey color */
    font: 500 12px/1.2 ui-sans-serif, system-ui, -apple-system;
    color: #777;
    opacity:0; transform:translateY(6px);
    transition: opacity .25s ease, transform .25s ease;
    user-select:none;
  }
  .reveal-stamp.show{ opacity:1; transform:translateY(0); }

  .back-panel{
    position:absolute; top:var(--front-top); left:0; right:0; margin:auto;
    width:var(--front-img-size); height:var(--front-img-size);
    border-radius:12px; background:transparent;
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.05);
    display:grid; place-items:center; color:#333; font-size:12px; text-align:center;
  }

  /* Bottom control (below card) - Improved CSS Toggle & Hold Animation */
  .controls{ display:grid; justify-items:center; margin-top:4px; }
  .ctrl{
    display:inline-grid; grid-auto-flow:row; align-items:center; justify-items:center;
    gap:4px; padding:8px 12px; border-radius:8px; background:#fff;
    border:1px solid rgba(0,0,0,.12); box-shadow:0 8px 20px rgba(0,0,0,.12);
    cursor:pointer; position:relative; top:40px;
    overflow:hidden; /* Needed for the ::before pseudo-element */
  }

  /* Hold to reset visual timer */
  .ctrl:active::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.08);
    animation: hold-fill 0.65s linear forwards;
    z-index: 1;
    pointer-events: none;
  }
  @keyframes hold-fill {
    0% { transform: scaleX(0); transform-origin: left; }
    100% { transform: scaleX(1); transform-origin: left; }
  }

  .ctrl svg{ width:20px; height:20px; opacity:.9; z-index:2; }
  .ctrl .label{ font-size:8px; line-height:1; color:#333; opacity:.8; z-index:2; }
  .ctrl[aria-pressed="true"]{ border-color:#2563eb; }

  /* CSS-managed icon toggle */
  .ctrl[aria-pressed="true"] #icon-play,
  .ctrl[aria-pressed="false"] #icon-pause {
    display: none;
  }
  .ctrl[aria-pressed="true"] #icon-pause,
  .ctrl[aria-pressed="false"] #icon-play {
    display: block;
  }
  
  .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,1px,1px); white-space:nowrap; border:0; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="scene" id="scene">
      <div class="card" id="card">
        <div class="face" id="frontFace">
          <div class="front-art" id="frontArt">
            <canvas class="scratch-layer" id="scratch"></canvas>
          </div>
          <div class="signature">SCRATCH CARD<br>BY SCRATCH</div>
          <div class="reveal-stamp" id="revealStamp" aria-live="polite"></div>
        </div>

        <div class="face back">
          <div class="back-panel">With Love, Xoxo</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="ctrl" id="ctrl" aria-pressed="true">
        <span class="sr-only">Hold to reset.</span>
        <svg id="icon-pause" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/></svg>
        <svg id="icon-play"  viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
        <span class="label">Hold to reset</span>
      </button>
    </div>
  </div>

<script>
(() => {
  /* -------- DOM Element Cache -------- */
  const scene = document.getElementById('scene');
  const card  = document.getElementById('card');
  const ctrl  = document.getElementById('ctrl');
  const frontArt = document.getElementById('frontArt');
  const scratchCanvas = document.getElementById('scratch');
  const revealStamp = document.getElementById('revealStamp');

  /* -------- State Grouping for Maintainability -------- */
  const cardState = {
    rotX: -6, rotY: 24, scale: 1,
    autoId: 0,
    autoOn: true,
  };

  const pointerState = {
    dragging: false,
    lastX: 0, lastY: 0,
    activePointerId: null,
  };

  const holoState = {
    lastRY: cardState.rotY, lastRX: cardState.rotX,
    holoX: 0.5, holoY: 0.45,
  };

  const scratchState = {
    ctx: null,
    revealedStamped: false,
    ratioCheckTimer: null,
    brushBase: 0,
    lastDabX: null, lastDabY: null,
  };

  /* -------- Helper Functions -------- */
  const rootStyle = document.documentElement.style;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function apply(){
    card.style.transform = `rotateX(${cardState.rotX}deg) rotateY(${cardState.rotY}deg) scale(${cardState.scale})`;
    updateHolo();
  }

  /* -------- Holographic Model: Improved Dynamics -------- */
  function updateHolo(){
    rootStyle.setProperty('--holo-phase', `${cardState.rotY}deg`);
    rootStyle.setProperty('--holo-tilt-x', `${cardState.rotX * 0.25}deg`);
    
    const dRY = cardState.rotY - holoState.lastRY;
    const dRX = cardState.rotX - holoState.lastRX;
    const vMag = Math.min(1, Math.hypot(dRY, dRX) / 12);
    
    const intensity = cardState.autoOn ? Math.max(0.12, vMag * 0.8) : vMag * 0.9;
    
    rootStyle.setProperty('--holo-intensity', intensity.toFixed(3));
    rootStyle.setProperty('--holo-x', `${holoState.holoX * 100}%`);
    rootStyle.setProperty('--holo-y', `${holoState.holoY * 100}%`);
    
    holoState.lastRY = cardState.rotY; 
    holoState.lastRX = cardState.rotX;
  }

  function tick(){
    if (!cardState.autoOn) return;
    
    cardState.rotY += 0.18;
    
    const autoTime = performance.now() * 0.001;
    holoState.holoX = 0.5 + Math.cos(autoTime * 0.7) * 0.25;
    holoState.holoY = 0.5 + Math.sin(autoTime * 0.5) * 0.2;
    
    apply();
    cardState.autoId = requestAnimationFrame(tick);
  }

  function setAuto(on){
    cardState.autoOn = on;
    ctrl.setAttribute('aria-pressed', on ? 'true' : 'false');
    cancelAnimationFrame(cardState.autoId);
    if (on) cardState.autoId = requestAnimationFrame(tick);
  }

  function flip(){ cardState.rotY += 180; apply(); }

  /* -------- Drag/Rotation Handlers -------- */
  function onDown(e){
    if (e.target === scratchCanvas) return; 
    e.preventDefault();
    pointerState.dragging = true;
    pointerState.activePointerId = e.pointerId;
    pointerState.lastX = e.clientX; 
    pointerState.lastY = e.clientY;
    scene.setPointerCapture(pointerState.activePointerId);
    setAuto(false);
  }

  function onMove(e){
    if(!pointerState.dragging || e.pointerId !== pointerState.activePointerId) return;
    const dx = e.clientX - pointerState.lastX;
    const dy = e.clientY - pointerState.lastY;
    
    cardState.rotY += dx * 0.15;
    cardState.rotX -= dy * 0.15;
    cardState.rotX = clamp(cardState.rotX, -75, 75);
    
    const rect = card.getBoundingClientRect();
    holoState.holoX = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    holoState.holoY = clamp((e.clientY - rect.top) / rect.height, 0, 1);
    
    pointerState.lastX = e.clientX; 
    pointerState.lastY = e.clientY;
    apply();
  }

  function endDrag(){
    if(!pointerState.dragging) return;
    pointerState.dragging = false;
    if (pointerState.activePointerId !== null) { 
      try { scene.releasePointerCapture(pointerState.activePointerId); } catch(e){} 
    }
    pointerState.activePointerId = null;
    
    if (ctrl.getAttribute('aria-pressed') === 'true') {
        setAuto(true);
    }
  }

  scene.addEventListener('pointerdown', onDown, {passive:false});
  scene.addEventListener('pointermove', onMove, {passive:true});
  scene.addEventListener('pointerup',   e=>{ if(e.pointerId===pointerState.activePointerId) endDrag(); }, {passive:true});
  scene.addEventListener('pointercancel',e=>{ if(e.pointerId===pointerState.activePointerId) endDrag(); }, {passive:true});
  scene.addEventListener('lostpointercapture', endDrag, {passive:true});
  scene.addEventListener('pointerleave', e=>{ if(e.pointerId===pointerState.activePointerId) endDrag(); }, {passive:true});
  window.addEventListener('pointerup', endDrag, {passive:true});
  scene.addEventListener('dblclick', flip, {passive:true});

  /* ---------------- SCRATCH FOIL MODEL ---------------- */
  function roundedRectPath(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }

  function initScratch(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = frontArt.clientWidth;
    const h = frontArt.clientHeight;

    scratchCanvas.width  = Math.round(w * dpr);
    scratchCanvas.height = Math.round(h * dpr);
    scratchCanvas.style.width  = w + 'px';
    scratchCanvas.style.height = h + 'px';

    scratchState.ctx = scratchCanvas.getContext('2d', { willReadFrequently: true });
    const ctx = scratchState.ctx;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.save();
    roundedRectPath(ctx, 0, 0, w, h, 12);
    ctx.clip();
    
    // 1. Base opaque metallic layer
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    const g = ctx.createLinearGradient(0, 0, w, h);
    g.addColorStop(0,   '#b8c0c8');
    g.addColorStop(0.5, '#aab4bc');
    g.addColorStop(1,   '#c0c8d0');
    ctx.fillStyle = g;
    ctx.fillRect(-1, -1, w+2, h+2);

    // 2. Brushed metallic streaks
    ctx.globalAlpha = 0.08;
    for(let i=0; i < 150; i++){
      const y = Math.random()*h;
      const H = Math.random()*2 + 0.5;
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(0, y, w, H);
    }
    ctx.globalAlpha = 1;

    // 3. Fine Speckle
    const speckles = Math.floor(w * h / 50);
    ctx.globalAlpha = 0.25;
    for(let i=0; i < speckles; i++){
      const x = Math.random()*w;
      const y = Math.random()*h;
      const r = Math.random()*0.8 + 0.2;
      ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.3)';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 4. Set final state for scratching
    ctx.globalCompositeOperation = 'destination-out';
    
    scratchState.revealedStamped = false;
    scratchState.brushBase = Math.max(18, Math.min(scratchCanvas.clientWidth, scratchCanvas.clientHeight) * 0.045);
    revealStamp.classList.remove('show');
    scratchState.lastDabX = null;
    scratchState.lastDabY = null;
  }

  function attachScratchHandlers(){
    let scratching = false;
    let pointerId = null;
    const ctx = scratchState.ctx;
    
    function localCoords(e){
      const b = scratchCanvas.getBoundingClientRect();
      return { x: e.clientX - b.left, y: e.clientY - b.top };
    }

    function dab(x, y){
      const brushBase = scratchState.brushBase;
      if (scratchState.lastDabX === null) {
        ctx.beginPath();
        ctx.arc(x, y, brushBase, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.lineCap = 'round';
        ctx.lineWidth = brushBase * 2;
        ctx.beginPath();
        ctx.moveTo(scratchState.lastDabX, scratchState.lastDabY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, brushBase, 0, Math.PI*2);
        ctx.fill();
      }
      scratchState.lastDabX = x;
      scratchState.lastDabY = y;
    }

    function onScratchDown(e){
      e.preventDefault(); e.stopPropagation();
      scratching = true; pointerId = e.pointerId;
      if (cardState.autoOn) setAuto(false);
      const {x,y} = localCoords(e); dab(x,y);
    }
    function onScratchMove(e){
      if(!scratching || e.pointerId !== pointerId) return;
      e.preventDefault(); e.stopPropagation();
      const {x,y} = localCoords(e); dab(x,y);
    }
    function onScratchEnd(){
      if(!scratching) return;
      scratching = false; pointerId = null;
      scratchState.lastDabX = null; 
      scratchState.lastDabY = null;

      clearTimeout(scratchState.ratioCheckTimer);
      scratchState.ratioCheckTimer = setTimeout(() => {
        const ratio = getClearedRatio();
        if (!scratchState.revealedStamped && ratio >= 0.40){
          scratchState.revealedStamped = true;
          revealStamp.textContent = `Revealed on ${formatStamp()}`;
          revealStamp.classList.add('show');
        }
      }, 200);

      if (ctrl.getAttribute('aria-pressed') === 'true') {
        setAuto(true);
      }
    }

    scratchCanvas.onpointerdown = onScratchDown;
    scratchCanvas.onpointermove = onScratchMove;
    scratchCanvas.onpointerup = onScratchEnd;
    scratchCanvas.onpointercancel = onScratchEnd;
    scratchCanvas.onpointerleave = onScratchEnd;
  }

  function getClearedRatio(){
    if (!scratchState.ctx) return 0;
    const w = scratchCanvas.width;
    const h = scratchCanvas.height;
    const step = Math.max(2, Math.round(Math.min(w, h) / 240));
    const data = scratchState.ctx.getImageData(0,0,w,h).data;
    let cleared = 0, total = 0;
    
    for(let y=0; y<h; y+=step){
      for(let x=0; x<w; x+=step){
        const a = data[((y*w)+x)*4 + 3];
        if (a < 10) cleared++;
        total++;
      }
    }
    return total ? cleared / total : 0;
  }

  function formatStamp(){
    const d = new Date();
    return d.toLocaleString(undefined, {
      year:'numeric', month:'short', day:'numeric',
      hour:'2-digit', minute:'2-digit', hour12:false
    }).replace(',', '');
  }

  const ro = new ResizeObserver(() => { initScratch(); });
  ro.observe(frontArt);

  /* -------- Control button: tap toggles auto, hold resets -------- */
  function reset(){
    cardState.rotX = -6; cardState.rotY = 24; cardState.scale = 1;
    initScratch();
    if (ctrl.getAttribute('aria-pressed') === 'true') {
        setAuto(true);
    } else {
        apply();
    }
  }
  let holdTimer = 0;
  
  ctrl.addEventListener('click',()=>{
    if (ctrl.dataset.longpress === '1'){ ctrl.dataset.longpress = '0'; return; }
    setAuto(!cardState.autoOn);
  });
  
  ctrl.addEventListener('pointerdown',()=>{ 
    holdTimer=setTimeout(()=>{ 
      ctrl.dataset.longpress='1'; 
      reset(); 
    },650); 
  });
  ctrl.addEventListener('pointerup',()=>clearTimeout(holdTimer),{passive:true});
  ctrl.addEventListener('pointerleave',()=>clearTimeout(holdTimer),{passive:true});
  ctrl.addEventListener('pointercancel',()=>clearTimeout(holdTimer),{passive:true});

  /* -------- Start -------- */
  apply();
  setAuto(true);
  initScratch();
  attachScratchHandlers();
})();
</script>
</body>
</html>
