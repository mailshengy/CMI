<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Mobile 3D Polaroid Card</title>
<style>
  :root{
    /* Auto-scale the card for mobile first; grows on tablets/desktops */
    --card-min: 240px;
    --card-max: 360px;
    --card-width: clamp(var(--card-min), 88vw, var(--card-max));
    --photo-aspect: 3/4;
    --polaroid-bg: #fff;
    --caption-color:#111;
    --shadow: 0 18px 38px rgba(0,0,0,.22), 0 3px 10px rgba(0,0,0,.14);
    --edge-shadow: inset 0 0 0 1px rgba(0,0,0,.08);
    --accent: #2962ff;
    --safe-pad: max(12px, env(safe-area-inset-left));
  }

  /* Subtle, battery-friendly background; simplified on small screens */
  body{
    margin:0;
    min-height:100svh;
    display:grid;
    place-items:center;
    background: radial-gradient(1000px 500px at 20% 20%, #f7fafc 0%, #e9eef7 50%, #dfe6f5 100%);
    font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
    -webkit-tap-highlight-color: transparent;
  }
  @media (max-width:480px){
    body{ background:#eef2f8; }
  }

  .wrap{
    width:100%;
    display:grid;
    gap:14px;
    justify-items:center;
    padding: calc(env(safe-area-inset-top,0) + 8px) var(--safe-pad) calc(env(safe-area-inset-bottom,0) + 14px);
  }

  .title{
    font-size: clamp(16px, 4.2vw, 20px);
    font-weight: 700;
    letter-spacing:.2px;
    color:#111;
  }

  .scene{
    width:min(92vw, 560px);
    aspect-ratio: 16/11;
    display:grid; place-items:center;
    perspective: clamp(800px, 120vw, 1400px); /* gentler on phones */
    perspective-origin: 50% 40%;
    user-select:none;
    touch-action: none; /* prevent page scroll while dragging */
    contain: layout paint; /* isolate for performance */
  }

  .card{
    width: var(--card-width);
    transform-style: preserve-3d;
    transition: transform .6s cubic-bezier(.2,.8,.2,1);
    will-change: transform;
  }
  .card__inner{ position:relative; transform-style:preserve-3d; }

  .face{
    position:absolute; inset:0;
    display:grid; place-items:center;
    background:var(--polaroid-bg);
    border-radius: 10px;
    box-shadow: var(--edge-shadow), var(--shadow);
    backface-visibility:hidden;
    -webkit-backface-visibility:hidden;
  }

  /* Polaroid layout */
  .polaroid{
    display:grid; grid-template-rows: 1fr auto;
    padding:12px 12px 28px 12px; gap:10px;
  }
  .photo{
    width:100%;
    aspect-ratio: var(--photo-aspect);
    border-radius: 8px;
    overflow:hidden; position:relative;
    box-shadow: 0 2px 6px rgba(0,0,0,.08) inset;
    background: #ddd center/cover no-repeat;
    background-image:url('https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&w=1200&auto=format&fit=crop');
    transform: translateZ(1px); /* avoid texture shimmer on iOS */
  }
  .caption{
    height: 46px;
    display:flex; align-items:center; justify-content:center;
    font: 700 clamp(12px, 3.8vw, 14px)/1.1 "Segoe UI", system-ui, -apple-system;
    letter-spacing:.2px; color: var(--caption-color);
  }

  .back{
    transform: rotateY(180deg);
    padding:16px;
    text-align:center;
  }
  .back .label{ font-weight:800; margin-bottom:6px; font-size: clamp(12px, 3.5vw, 14px); }
  .back p{ margin:6px 0 0; font-size: clamp(11px, 3.2vw, 13px); opacity:.8; }

  /* Controls: big tap targets, sticky corner, safe-area aware */
  .hud{
    position: sticky; bottom: 0; z-index: 2;
    display:flex; gap:8px; align-items:center; justify-content:center;
    padding: 8px calc(env(safe-area-inset-left,0) + 8px) 0 calc(env(safe-area-inset-right,0) + 8px);
    width: 100%;
  }
  .btn{
    appearance:none; border:1px solid rgba(0,0,0,.12);
    padding: 12px 14px; border-radius:12px; background:white; cursor:pointer;
    font: 700 14px/1 system-ui; letter-spacing:.2px;
    min-width: 44px; min-height: 44px; /* mobile hit target */
    box-shadow: 0 4px 12px rgba(0,0,0,.08);
    touch-action: manipulation;
  }
  .btn[aria-pressed="true"]{ border-color:var(--accent); color:var(--accent); }

  .hint{
    font-size:12px; opacity:.65; text-align:center; padding:0 10px;
  }
  @media (max-width:420px){
    .hint{ display:none; }
  }

  /* Reduced motion = no auto/inertia/tiny transitions */
  @media (prefers-reduced-motion: reduce){
    .card, .card__inner{ transition:none !important; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="title">Spin the Polaroid — Mobile Optimized</div>

    <div class="scene" id="scene" tabindex="0" aria-label="3D polaroid card. Drag to spin. Double-tap to flip.">
      <div class="card" id="card" role="img" aria-roledescription="polaroid card">
        <div class="card__inner" id="inner">
          <div class="face polaroid">
            <div class="photo" aria-hidden="true"></div>
            <div class="caption">Curiosity Meets Imagination</div>
          </div>
          <div class="face back">
            <div>
              <div class="label">Polaroid Back</div>
              <p>Double-tap/click to flip</p>
              <p>Drag to spin • Pinch/scroll to scale</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="hud" aria-label="controls">
      <button id="tilt" class="btn" aria-pressed="false" title="Enable device tilt">Tilt</button>
      <button id="auto" class="btn" aria-pressed="false" title="Toggle auto-spin">Auto</button>
      <button id="reset" class="btn" title="Reset orientation">Reset</button>
    </div>

    <div class="hint">Tip: drag anywhere to rotate. Shift-drag = slower, Option/Alt-drag = finer. “Tilt” uses your phone’s motion sensors (prompts on iOS).</div>
  </div>

<script>
(() => {
  const scene = document.getElementById('scene');
  const card  = document.getElementById('card');
  const inner = document.getElementById('inner');
  const btnAuto = document.getElementById('auto');
  const btnReset = document.getElementById('reset');
  const btnTilt = document.getElementById('tilt');

  // --- State ---
  let rotX = -8, rotY = 18;
  let scale = 1;
  let flipping = false;

  let dragging = false;
  let lastX = 0, lastY = 0;
  let vx = 0, vy = 0;
  let rafId = 0, autoId = 0;

  let tiltOn = false;
  let tiltHandler = null;

  const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // --- Helpers ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const apply = () => {
    card.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg) scale(${scale}) translateZ(0)`;
  };
  apply();

  const flip = () => {
    flipping = !flipping;
    inner.style.transform = `rotateY(${flipping ? 180 : 0}deg)`;
  };

  const setAuto = (on) => {
    btnAuto.setAttribute('aria-pressed', on ? 'true' : 'false');
    cancelAnimationFrame(autoId);
    if (on && !reduceMotion){
      const tick = () => {
        rotY += 0.25; // a hair faster on mobile for feedback
        apply();
        autoId = requestAnimationFrame(tick);
      };
      autoId = requestAnimationFrame(tick);
    }
  };

  // --- Tilt (DeviceMotion) with iOS permission flow ---
  const supportsDeviceOrientation = 'DeviceOrientationEvent' in window || 'DeviceMotionEvent' in window;
  async function toggleTilt() {
    if (tiltOn){
      window.removeEventListener('deviceorientation', tiltHandler);
      tiltOn = false;
      btnTilt.setAttribute('aria-pressed','false');
      return;
    }
    if (!supportsDeviceOrientation) {
      alert('Device motion not supported on this device/browser.');
      return;
    }

    // iOS permission (secure context required: https / local file might not prompt)
    try{
      if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function'){
        const r = await DeviceMotionEvent.requestPermission();
        if (r !== 'granted') { alert('Motion permission denied.'); return; }
      }
      if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
        const r2 = await DeviceOrientationEvent.requestPermission();
        if (r2 !== 'granted') { /* some browsers only use one of these */ }
      }
    }catch(e){ /* ignore; some browsers throw if not needed */ }

    const strength = 0.35; // lower = gentler
    tiltHandler = (e) => {
      // Use gamma (left-right) and beta (front-back); normalize to [-45,45]
      const g = (e.gamma ?? 0);
      const b = (e.beta ?? 0);

      // Map to rotation deltas; clamp to keep it chill
      const targetY = clamp(g * strength, -35, 35);
      const targetX = clamp(-(b - 45) * strength, -35, 35);

      // Ease towards target for smoothness
      rotY += (targetY - rotY) * 0.08;
      rotX += (targetX - rotX) * 0.08;
      apply();
    };

    window.addEventListener('deviceorientation', tiltHandler, { passive:true });
    tiltOn = true;
    btnTilt.setAttribute('aria-pressed','true');
  }

  // --- Buttons ---
  btnReset.addEventListener('click', () => {
    rotX = -8; rotY = 18; scale = 1; flipping = false;
    inner.style.transform = 'rotateY(0deg)';
    apply();
  });
  btnAuto.addEventListener('click', () => setAuto(btnAuto.getAttribute('aria-pressed') !== 'true'));
  btnTilt.addEventListener('click', toggleTilt);

  // --- Pointer controls (touch + mouse) ---
  const onDown = (e) => {
    if (e.pointerType === 'touch') e.preventDefault();
    dragging = true;
    lastX = e.clientX; lastY = e.clientY;
    vx = vy = 0;
    scene.setPointerCapture(e.pointerId);
    cancelAnimationFrame(rafId);
  };
  const onMove = (e) => {
    if(!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;

    const mod = e.shiftKey ? 0.4 : e.altKey ? 0.2 : 0.8;

    rotY += dx * 0.15 * mod;
    rotX -= dy * 0.15 * mod;
    rotX = clamp(rotX, -75, 75);

    vx = dx; vy = dy;
    lastX = e.clientX; lastY = e.clientY;
    apply();
  };
  const onUp = (e) => {
    if (!dragging) return;
    dragging = false;
    scene.releasePointerCapture(e.pointerId);

    if (reduceMotion) return;

    // gentle inertia
    let decay = 0.94;
    let _vx = vx, _vy = vy;
    const spin = () => {
      if (Math.hypot(_vx, _vy) < 0.2) return;
      rotY += _vx * 0.12;
      rotX -= _vy * 0.12;
      rotX = clamp(rotX, -75, 75);
      _vx *= decay; _vy *= decay;
      apply();
      rafId = requestAnimationFrame(spin);
    };
    rafId = requestAnimationFrame(spin);
  };

  scene.addEventListener('pointerdown', onDown, {passive:false});
  scene.addEventListener('pointermove', onMove, {passive:true});
  scene.addEventListener('pointerup', onUp, {passive:true});
  scene.addEventListener('pointercancel', onUp, {passive:true});
  scene.addEventListener('dblclick', () => { flip(); });

  // mobile-friendly double-tap
  let tapTimer = 0;
  scene.addEventListener('touchend', () => {
    const now = Date.now();
    if(now - tapTimer < 280) flip();
    tapTimer = now;
  }, {passive:true});

  // Wheel / pinch to scale (wheel works on desktop; pinch triggers wheel on some Android browsers)
  scene.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    scale = clamp(scale * (delta > 0 ? 0.96 : 1.04), 0.85, 1.35);
    apply();
  }, {passive:false});

  // Keyboard (desktop & accessibility)
  scene.addEventListener('keydown', (e) => {
    const step = e.altKey ? 1 : 3;
    if (e.key === 'ArrowLeft'){ rotY -= step; apply(); }
    if (e.key === 'ArrowRight'){ rotY += step; apply(); }
    if (e.key === 'ArrowUp'){ rotX -= step; apply(); }
    if (e.key === 'ArrowDown'){ rotX += step; apply(); }
    if (e.key === ' ' || e.key === 'Enter'){ flip(); }
    if (e.key === '0'){ rotX=-8; rotY=18; scale=1; flipping=false; inner.style.transform='rotateY(0deg)'; apply(); }
    if (e.key === 'a'){ setAuto(btnAuto.getAttribute('aria-pressed') !== 'true'); }
  });

  // Prevent rubber-band scroll on iOS while dragging
  document.addEventListener('touchmove', (e) => {
    if (dragging) e.preventDefault();
  }, {passive:false});

  // Start with auto off & tilt off to save batteryd
  setAuto(true);
})();
</script>
</body>
</html>
